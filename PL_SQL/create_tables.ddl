-- Generated by Oracle SQL Developer Data Modeler 21.2.0.183.1957
--   at:        2023-05-28 15:19:04 EEST
--   site:      Oracle Database 11g
--   type:      Oracle Database 11g



-- predefined type, no DDL - MDSYS.SDO_GEOMETRY

-- predefined type, no DDL - XMLTYPE

CREATE TABLE comenzi (
    id_comanda   NUMBER(5) NOT NULL,
    data_comanda DATE NOT NULL,
    id_client    NUMBER(5) NOT NULL,
    total_plata  NUMBER NOT NULL,
    finalizata   CHAR(1) NOT NULL
)
LOGGING;

ALTER TABLE comenzi ADD CONSTRAINT comanda_data_ck CHECK ( data_comanda >= '10-feb-2021' );

ALTER TABLE comenzi ADD CONSTRAINT cost_ck CHECK ( total_plata >= 0 );

ALTER TABLE comenzi ADD CONSTRAINT comanda_pk PRIMARY KEY ( id_comanda );

CREATE TABLE carduri_fidelitate (
    id_client           NUMBER(5) NOT NULL,
    id_card             NUMBER(5) NOT NULL,
    data_nastere_client DATE,
    puncte_acumulate    NUMBER DEFAULT 0 NOT NULL
)
LOGGING;

ALTER TABLE carduri_fidelitate ADD CONSTRAINT card_fidelitate_pk PRIMARY KEY ( id_client );

ALTER TABLE carduri_fidelitate ADD CONSTRAINT "client.id_card_uk" UNIQUE ( id_card );

CREATE TABLE tipuri_pizza (
    id_pizza NUMBER(2) NOT NULL,
    denumire VARCHAR2(20) NOT NULL,
    gramaj   NUMBER(4) NOT NULL,
    pret     NUMBER(2) NOT NULL
)
LOGGING;

ALTER TABLE tipuri_pizza
    ADD CONSTRAINT tipuri_pizza_denumire_ck CHECK ( length(TRIM(denumire)) > 0
                                                    AND REGEXP_LIKE ( denumire,
                                                                      '^[a-zA-Z ]*$' ) );

ALTER TABLE tipuri_pizza
    ADD CONSTRAINT tipuri_pizza_gramaj_ck CHECK ( gramaj BETWEEN 0 AND 2000 );

ALTER TABLE tipuri_pizza
    ADD CONSTRAINT tipuri_pizza_pret_ck CHECK ( pret BETWEEN 1 AND 99 );

ALTER TABLE tipuri_pizza ADD CONSTRAINT tipuri_pizza_pk PRIMARY KEY ( id_pizza );

ALTER TABLE tipuri_pizza ADD CONSTRAINT tipuri_pizza__un UNIQUE ( denumire );

CREATE TABLE clienti (
    id_client     NUMBER(5) NOT NULL,
    nume          VARCHAR2(30) NOT NULL,
    prenume       VARCHAR2(30) NOT NULL,
    telefon       VARCHAR2(10) NOT NULL,
    email         VARCHAR2(60) NOT NULL,
    cartier       VARCHAR2(30) NOT NULL,
    numar_cartier INTEGER NOT NULL,
    nr_bloc       INTEGER,
    etaj          INTEGER,
    nr_apartament INTEGER
)
LOGGING;

ALTER TABLE clienti ADD CHECK ( id_client BETWEEN 1 AND 99999 );

ALTER TABLE clienti
    ADD CONSTRAINT client_nume_ck CHECK ( length(nume) > 1
                                          AND REGEXP_LIKE ( nume,
                                                            '^[A-Za-z]+$' ) );

ALTER TABLE clienti
    ADD CONSTRAINT client_prenume_ck CHECK ( length(prenume) > 1
                                             AND REGEXP_LIKE ( prenume,
                                                               '^[A-Za-z]+$' ) );

ALTER TABLE clienti
    ADD CONSTRAINT client_telefon_ck CHECK ( REGEXP_LIKE ( telefon,
                                                           '^07[0-9]{8}$' ) );

ALTER TABLE clienti
    ADD CONSTRAINT client_email_ck CHECK ( REGEXP_LIKE ( email,
                                                         '[a-z0-9._%-]+@[a-z0-9._%-]+\.[a-z]{2,4}' ) );

ALTER TABLE clienti
    ADD CONSTRAINT client_cartier_ck CHECK ( length(cartier) > 1
                                             AND REGEXP_LIKE ( cartier,
                                                               '^[A-Za-z+$]' ) );

ALTER TABLE clienti
    ADD CONSTRAINT client_numar_cartier_ck CHECK ( REGEXP_LIKE ( numar_cartier,
                                                                 '^[0-9]+$' )
                                                   OR numar_cartier BETWEEN 1 AND 999 );

ALTER TABLE clienti
    ADD CONSTRAINT client_nr_bloc_ck CHECK ( REGEXP_LIKE ( nr_bloc,
                                                           '^[0-9]+$' )
                                             OR nr_bloc BETWEEN 1 AND 999 );

ALTER TABLE clienti
    ADD CONSTRAINT client_etaj_ck CHECK ( REGEXP_LIKE ( etaj,
                                                        '^[0-9]+$' )
                                          AND etaj BETWEEN 0 AND 10 );

ALTER TABLE clienti
    ADD CONSTRAINT client_nr_apartament_ck CHECK ( REGEXP_LIKE ( nr_apartament,
                                                                 '^[0-9]+$' )
                                                   OR nr_apartament BETWEEN 1 AND 999 );

ALTER TABLE clienti ADD CONSTRAINT client_pk PRIMARY KEY ( id_client );

ALTER TABLE clienti ADD CONSTRAINT client_email_uk UNIQUE ( email );

ALTER TABLE clienti ADD CONSTRAINT client_telefon_uk UNIQUE ( telefon );

CREATE TABLE produse_comanda (
    id_comanda NUMBER(5) NOT NULL,
    id_pizza   NUMBER(2) NOT NULL,
    cantitate  INTEGER
)
LOGGING;

ALTER TABLE produse_comanda ADD CONSTRAINT check_cantitate_produs CHECK ( cantitate > 0 );

ALTER TABLE produse_comanda ADD CONSTRAINT produse_comanda_pk PRIMARY KEY ( id_comanda,
                                                                            id_pizza );

CREATE OR REPLACE PACKAGE vizualizare_informatii IS
    FUNCTION extrage_id_client (v_nr_telefon_client IN clienti.telefon%TYPE) RETURN NUMBER;
    FUNCTION extrage_informatii_client (v_nr_telefon_client IN clienti.telefon%TYPE) RETURN clienti%ROWTYPE;
    
    FUNCTION extrage_id_pizza (p_denumire_pizza IN tipuri_pizza.denumire%TYPE) RETURN NUMBER;
    
    PROCEDURE vizualizare_toate_comenzile;
    PROCEDURE vizualizare_comenzi_finalizate;
    PROCEDURE vizualizare_comenzi_nefinalizate;
    
    PROCEDURE top_3_clienti_fideli;
    PROCEDURE top_3_pizza_comandate;
    
    PROCEDURE vizualizare_meniu;
END vizualizare_informatii;
/

CREATE OR REPLACE PACKAGE BODY vizualizare_informatii AS
    FUNCTION extrage_id_client
        (v_nr_telefon_client IN clienti.telefon%TYPE)
        RETURN NUMBER
        IS
            v_id_client clienti.id_client%TYPE;
        BEGIN
            SELECT id_client INTO v_id_client FROM clienti WHERE telefon = v_nr_telefon_client;
            RETURN v_id_client;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                DBMS_OUTPUT.put_line('Nu a fost gasit vreun client cu numarul de telefon: ' || v_nr_telefon_client);
                RETURN -1;
    END extrage_id_client;
    
    FUNCTION extrage_informatii_client
        (v_nr_telefon_client IN clienti.telefon%TYPE) 
        RETURN clienti%ROWTYPE
        IS
            v_client clienti%ROWTYPE;
        BEGIN
            SELECT * INTO v_client FROM clienti WHERE telefon = v_nr_telefon_client;
            RETURN v_client;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                DBMS_OUTPUT.put_line('Nu a fost gasit vreun client cu numarul de telefon: ' || v_nr_telefon_client);
                RETURN NULL; -- Return NULL or handle the exception accordingly
    END extrage_informatii_client;
    
    FUNCTION extrage_id_pizza
        (p_denumire_pizza IN tipuri_pizza.denumire%TYPE)
        RETURN NUMBER
        IS
            v_id_pizza tipuri_pizza.id_pizza%TYPE;
        BEGIN
            SELECT id_pizza INTO v_id_pizza 
            FROM tipuri_pizza 
            WHERE denumire = p_denumire_pizza;
            RETURN v_id_pizza;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                DBMS_OUTPUT.put_line('Nu a fost gasita vreo pizza cu denumirea: ' || p_denumire_pizza);
                RETURN -1;
    END extrage_id_pizza;
    
    PROCEDURE top_3_clienti_fideli 
        IS
            CURSOR c_clienti IS
                SELECT id_client, COUNT(*) AS numar_comenzi
                FROM comenzi
                WHERE finalizata = 1
                GROUP BY id_client
                ORDER BY COUNT(*) DESC;   
        BEGIN
            DBMS_OUTPUT.PUT_LINE('Top 3 clienti fideli...............');
            
            FOR r_client IN c_clienti LOOP
                DECLARE
                  client_name clienti.nume%TYPE;
                BEGIN
                    EXIT WHEN c_clienti%ROWCOUNT > 3;
                    
                    SELECT nume || ' ' || prenume INTO client_name
                      FROM clienti
                      WHERE id_client = r_client.id_client;
                    DBMS_OUTPUT.PUT_LINE('Clientul ' || client_name || ' are ' || r_client.numar_comenzi || ' comenzi');
                END;
            END LOOP;
    END top_3_clienti_fideli; 
    
    PROCEDURE top_3_pizza_comandate
        IS
            CURSOR c_pizza_comandate IS
                SELECT id_pizza, COUNT(*) AS numar_pizza
                FROM produse_comanda
                GROUP BY id_pizza
                ORDER BY COUNT(*) DESC;
        BEGIN
            DBMS_OUTPUT.PUT_LINE('Top 3 pizza comandate.............................');
        
            FOR r_pizza in c_pizza_comandate LOOP
                DECLARE
                    pizza_denumire tipuri_pizza.denumire%TYPE;
                BEGIN
                    EXIT WHEN c_pizza_comandate%ROWCOUNT > 3;
                    
                    SELECT denumire INTO pizza_denumire
                        FROM tipuri_pizza
                        WHERE id_pizza = r_pizza.id_pizza;
                    DBMS_OUTPUT.PUT_LINE('Tipul de pizza ' || pizza_denumire || ' a fost comandata de ' || r_pizza.numar_pizza || ' ori.');
                    
                END;
            END LOOP;
    END top_3_pizza_comandate;
    
    PROCEDURE vizualizare_toate_comenzile 
        IS
            CURSOR c_comenzi IS
                SELECT * 
                FROM comenzi
                ORDER BY id_comanda, data_comanda;
        BEGIN
            DBMS_OUTPUT.PUT_LINE('Afisarea tuturor comenzilor............................');
            
            FOR r_comanda in c_comenzi LOOP
                DECLARE 
                    -- preiau toate produsele din comanda
                    CURSOR c_produse_comanda IS
                        SELECT id_pizza, cantitate
                        FROM produse_comanda
                        WHERE id_comanda = r_comanda.id_comanda;
                BEGIN
                    DBMS_OUTPUT.PUT_LINE('Comanda cu id-ul: ' || r_comanda.id_comanda || ' si statusul finalizata: ' || r_comanda.finalizata);
                    
                    FOR r_pizza in c_produse_comanda LOOP
                        DECLARE
                            v_denumire_pizza tipuri_pizza.denumire%type;
                        BEGIN
                            SELECT denumire INTO v_denumire_pizza
                            FROM tipuri_pizza
                            WHERE id_pizza = r_pizza.id_pizza;
                            
                            DBMS_OUTPUT.PUT_LINE('Denumire: ' || v_denumire_pizza || ', cantitate: ' || r_pizza.cantitate || ' bucati.');
                        END;
                    END LOOP;
                    
                    DBMS_OUTPUT.PUT_LINE('');
                END;
            END LOOP;
    END vizualizare_toate_comenzile;
    
    PROCEDURE vizualizare_comenzi_nefinalizate 
        IS
            CURSOR c_comenzi IS
                SELECT * 
                FROM comenzi
                WHERE finalizata = 0
                ORDER BY id_comanda, data_comanda;
        BEGIN
            DBMS_OUTPUT.PUT_LINE('Afisarea comenzilor in procesare...................................');
            
            FOR r_comanda in c_comenzi LOOP
                DECLARE 
                    -- preiau toate produsele din comanda
                    CURSOR c_produse_comanda IS
                        SELECT id_pizza, cantitate
                        FROM produse_comanda
                        WHERE id_comanda = r_comanda.id_comanda;
                BEGIN
                    DBMS_OUTPUT.PUT_LINE('Comanda cu id-ul: ' || r_comanda.id_comanda || ' si statusul finalizata: ' || r_comanda.finalizata);
                    
                    FOR r_pizza in c_produse_comanda LOOP
                        DECLARE
                            v_denumire_pizza tipuri_pizza.denumire%type;
                        BEGIN
                            SELECT denumire INTO v_denumire_pizza
                            FROM tipuri_pizza
                            WHERE id_pizza = r_pizza.id_pizza;
                            
                            DBMS_OUTPUT.PUT_LINE('Denumire: ' || v_denumire_pizza || ', cantitate: ' || r_pizza.cantitate || ' bucati.');
                        END;
                    END LOOP;
                    
                    DBMS_OUTPUT.PUT_LINE('');
                END;
            END LOOP;
    END vizualizare_comenzi_nefinalizate;
    
    PROCEDURE vizualizare_comenzi_finalizate 
        IS
            CURSOR c_comenzi IS
                SELECT * 
                FROM comenzi
                WHERE finalizata = 1
                ORDER BY id_comanda, data_comanda;
        BEGIN
            DBMS_OUTPUT.PUT_LINE('Afisarea comenzilor finalizate...................................');
            
            FOR r_comanda in c_comenzi LOOP
                DECLARE 
                    -- preiau toate produsele din comanda
                    CURSOR c_produse_comanda IS
                        SELECT id_pizza, cantitate
                        FROM produse_comanda
                        WHERE id_comanda = r_comanda.id_comanda;
                BEGIN
                    DBMS_OUTPUT.PUT_LINE('Comanda cu id-ul: ' || r_comanda.id_comanda || ' si statusul finalizata: ' || r_comanda.finalizata);
                    
                    FOR r_pizza in c_produse_comanda LOOP
                        DECLARE
                            v_denumire_pizza tipuri_pizza.denumire%type;
                        BEGIN
                            SELECT denumire INTO v_denumire_pizza
                            FROM tipuri_pizza
                            WHERE id_pizza = r_pizza.id_pizza;
                            
                            DBMS_OUTPUT.PUT_LINE('Denumire: ' || v_denumire_pizza || ', cantitate: ' || r_pizza.cantitate || ' bucati.');
                        END;
                    END LOOP;
                    
                    DBMS_OUTPUT.PUT_LINE('');
                END;
            END LOOP;
    END vizualizare_comenzi_finalizate;
    
    PROCEDURE vizualizare_meniu
        IS
            CURSOR c_pizza IS
                SELECT * 
                FROM tipuri_pizza
                ORDER BY denumire ASC;
        BEGIN
            FOR r_pizza in c_pizza LOOP
                DBMS_OUTPUT.PUT_LINE('Denumire: ' || r_pizza.denumire || ', pret: ' || r_pizza.pret || ' lei, gramaj: ' || r_pizza.gramaj || ' grame.');
            END LOOP;
    END vizualizare_meniu;
END vizualizare_informatii;
/

CREATE OR REPLACE PACKAGE sterge_informatii IS
    PROCEDURE sterge_produs_comanda(
        p_id_comanda IN produse_comanda.id_comanda%TYPE,
        p_denumire_pizza  IN tipuri_pizza.denumire%TYPE
    );
END sterge_informatii;
/
CREATE OR REPLACE PACKAGE BODY sterge_informatii AS
    PROCEDURE sterge_produs_comanda(
        p_id_comanda IN produse_comanda.id_comanda%TYPE,
        p_denumire_pizza  IN tipuri_pizza.denumire%TYPE
    )
    IS
        v_id_pizza tipuri_pizza.id_pizza%TYPE;
    BEGIN
        v_id_pizza  := vizualizare_informatii.extrage_id_pizza(p_denumire_pizza);
    
        DELETE FROM produse_comanda
        WHERE id_comanda = p_id_comanda
          AND id_pizza = v_id_pizza;
          
        DBMS_OUTPUT.PUT_LINE('Inregistrarea a fost stearsa cu succes!');
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Tranzactia nu s-a efectuat cu succes! Eroare: ' || SQLERRM);
    END sterge_produs_comanda;
END sterge_informatii;
/

CREATE OR REPLACE PACKAGE actualizare_informatii IS
    PROCEDURE actualizare_status_comanda(
        p_id_comanda comenzi.id_comanda%TYPE
    );
    
    PROCEDURE actualizare_puncte_card(
        p_total_comanda NUMBER,
        p_id_client clienti.id_client%TYPE
    );
    
    PROCEDURE actualizare_produs_comanda(
        p_id_comanda comenzi.id_comanda%TYPE,
        p_denumire_pizza tipuri_pizza.denumire%TYPE,
        p_cantitate produse_comanda.cantitate%TYPE
    );
END actualizare_informatii;
/

CREATE OR REPLACE PACKAGE BODY actualizare_informatii AS
    PROCEDURE actualizare_status_comanda(
        p_id_comanda comenzi.id_comanda%TYPE
    )
    IS
    BEGIN
      UPDATE comenzi
      SET finalizata = 1
      WHERE id_comanda = p_id_comanda;
      
      COMMIT;
      DBMS_OUTPUT.PUT_LINE('Statusul comenzii cu id-ul '|| p_id_comanda ||' a fost efectuat cu succes.');
    EXCEPTION
      WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20201, 'Tranzactia nu s-a efectuat!!! A aparut o eroare la executarea update-ului.  Eroare: ' || SQLERRM);
        ROLLBACK;
    END actualizare_status_comanda;
    
    PROCEDURE actualizare_puncte_card(
        p_total_comanda NUMBER,
        p_id_client clienti.id_client%TYPE
    )
    IS
        v_total_puncte_anterior carduri_fidelitate.puncte_acumulate%type;
        v_total NUMBER;
    BEGIN
        SELECT puncte_acumulate INTO v_total_puncte_anterior FROM carduri_fidelitate WHERE id_client = p_id_client;
        v_total := v_total_puncte_anterior + 0.1 * p_total_comanda;
        UPDATE carduri_fidelitate set puncte_acumulate = v_total WHERE id_client = p_id_client;
            
        DBMS_OUTPUT.PUT_LINE('Tranzactie reusita, punctele au fost alocate! Clientul cu id-ul ' || p_id_client || ' are ' || v_total_puncte_anterior + 0.1 * p_total_comanda || ' puncte.');
    EXCEPTION
        WHEN VALUE_ERROR THEN
            DBMS_OUTPUT.PUT_LINE('Tranzactia nu s-a efectuat!!! Eroare: Invalid value conversion');
            DBMS_OUTPUT.PUT_LINE('Error at line: ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Tranzactia nu s-a efectuat!!! Eroare: ' || SQLERRM);
            DBMS_OUTPUT.PUT_LINE('Error at line: ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);

    END actualizare_puncte_card;
    
    PROCEDURE actualizare_produs_comanda(
        p_id_comanda comenzi.id_comanda%TYPE,
        p_denumire_pizza tipuri_pizza.denumire%TYPE,
        p_cantitate produse_comanda.cantitate%TYPE
    )
    IS
        v_id_pizza tipuri_pizza.id_pizza%TYPE;
        v_status_comanda comenzi.finalizata%TYPE;
    BEGIN
        v_id_pizza  := vizualizare_informatii.extrage_id_pizza(p_denumire_pizza);
        SELECT finalizata INTO v_status_comanda 
        FROM comenzi
        WHERE id_comanda = p_id_comanda;
        
        IF v_status_comanda = 0 THEN
            IF p_cantitate !=0 THEN
                UPDATE produse_comanda SET cantitate = p_cantitate WHERE id_comanda = p_id_comanda AND id_pizza = v_id_pizza;
                COMMIT;
                
                IF v_id_pizza != -1 THEN
                    DBMS_OUTPUT.PUT_LINE('S-a actualizat cu succes produsul ' || p_denumire_pizza || ' la comanda cu id-ul ' || p_id_comanda);
                ELSE
                    DBMS_OUTPUT.PUT_LINE('Tranzatia nu s-a efectuat!!! Eroare: Nu exista tipul de pizza solicitat.');
                    ROLLBACK;
                END IF;
            ELSE
                sterge_informatii.sterge_produs_comanda(p_id_comanda, p_denumire_pizza);
            END IF;
        ELSE
            DBMS_OUTPUT.PUT_LINE('Tranzatia nu s-a efectuat!!! Eroare: Comanda a fost deja finalizata, nu se mai pot modifica produsele din interiorul acesteia.');
        END IF;
    END actualizare_produs_comanda;
END actualizare_informatii;
/

CREATE TABLE stocuri_pizza (
    id_intrare_stoc INTEGER NOT NULL,
    cantitate       INTEGER DEFAULT 0 NOT NULL,
    id_pizza        NUMBER(2) NOT NULL
)
LOGGING;

ALTER TABLE stocuri_pizza ADD CONSTRAINT cantitate_ck CHECK ( cantitate >= 0 );

CREATE UNIQUE INDEX stocuri_pizza__idx ON
    stocuri_pizza (
        id_pizza
    ASC )
        LOGGING;

ALTER TABLE stocuri_pizza ADD CONSTRAINT stoc_pizza_pk PRIMARY KEY ( id_intrare_stoc );

CREATE OR REPLACE PACKAGE actualizare_stoc IS
    PROCEDURE actualizare_stoc_la_plasarea_comenzii (v_id_comanda IN comenzi.id_comanda%TYPE);
    FUNCTION extrage_id_intrare_stoc (v_id_pizza IN produse_comanda.id_pizza%TYPE) RETURN NUMBER;
    FUNCTION extrage_cantitate_curenta_stoc (v_id_intrare_stoc IN stocuri_pizza.id_intrare_stoc%TYPE) RETURN NUMBER;
END actualizare_stoc;
/
CREATE OR REPLACE PACKAGE BODY actualizare_stoc AS
    PROCEDURE actualizare_stoc_la_plasarea_comenzii 
    (v_id_comanda IN comenzi.id_comanda%TYPE)
    IS
        CURSOR c_produse_comanda IS
            SELECT id_pizza, cantitate
            FROM produse_comanda
            WHERE id_comanda = v_id_comanda;
        v_id_intrare_stoc stocuri_pizza.id_intrare_stoc%TYPE;
        v_cantitate_curenta stocuri_pizza.cantitate%TYPE;
    BEGIN
        FOR r_produs IN c_produse_comanda LOOP
            v_id_intrare_stoc := extrage_id_intrare_stoc(r_produs.id_pizza);
            v_cantitate_curenta := extrage_cantitate_curenta_stoc(v_id_intrare_stoc);
            
            UPDATE stocuri_pizza 
            SET cantitate = v_cantitate_curenta - r_produs.cantitate 
            WHERE id_intrare_stoc = v_id_intrare_stoc;
            
        END LOOP;
    END actualizare_stoc_la_plasarea_comenzii;

    FUNCTION extrage_id_intrare_stoc
        (v_id_pizza IN produse_comanda.id_pizza%TYPE)
        RETURN NUMBER
        IS
            v_id_intrare_stoc stocuri_pizza.id_intrare_stoc%TYPE;
        BEGIN
            SELECT id_intrare_stoc INTO v_id_intrare_stoc FROM stocuri_pizza WHERE id_pizza = v_id_pizza;
            RETURN v_id_intrare_stoc;
        END extrage_id_intrare_stoc;
         
         
    FUNCTION extrage_cantitate_curenta_stoc
        (v_id_intrare_stoc IN stocuri_pizza.id_intrare_stoc%TYPE)
        RETURN NUMBER
        IS
            v_cantitate_curenta produse_comanda.cantitate%TYPE;
        BEGIN
            SELECT cantitate INTO v_cantitate_curenta FROM stocuri_pizza WHERE id_intrare_stoc = v_id_intrare_stoc;
            RETURN v_cantitate_curenta;
        END extrage_cantitate_curenta_stoc;
    
END actualizare_stoc;
/

CREATE TABLE facturi (
    id_factura INTEGER NOT NULL,
    serie      VARCHAR2(15) NOT NULL,
    numar      INTEGER NOT NULL,
    id_comanda NUMBER(5) NOT NULL
)
LOGGING;

CREATE UNIQUE INDEX facturi__idx ON
    facturi (
        id_comanda
    ASC )
        LOGGING;

ALTER TABLE facturi ADD CONSTRAINT facturi_pk PRIMARY KEY ( id_factura );

CREATE OR REPLACE PACKAGE factura_package AS
    PROCEDURE inserare_serie_factura(v_id_comanda IN comenzi.id_comanda%TYPE);
    PROCEDURE actualizare_serie_factura;
END factura_package;
/

CREATE OR REPLACE PACKAGE BODY factura_package AS
    PROCEDURE inserare_serie_factura(v_id_comanda IN comenzi.id_comanda%TYPE)
    IS
    BEGIN
        INSERT INTO facturi (serie, id_comanda) VALUES (' ', v_id_comanda);
    END inserare_serie_factura;
    
    PROCEDURE actualizare_serie_factura
    IS
        v_numar facturi.numar%TYPE;
    BEGIN
        SELECT numar INTO v_numar FROM facturi ORDER BY id_factura DESC FETCH FIRST 1 ROWS ONLY;
        UPDATE facturi SET serie = 'FOOD-' || v_numar || '-IS' WHERE numar = v_numar;
    END actualizare_serie_factura;
END factura_package;
/

CREATE OR REPLACE PACKAGE inserare_informatii IS
    PROCEDURE insereaza_client_si_card(
        p_nume           VARCHAR2,
        p_prenume        VARCHAR2,
        p_telefon        VARCHAR2,
        p_email          VARCHAR2,
        p_cartier        VARCHAR2,
        p_numar_cartier  NUMBER,
        p_nr_bloc        NUMBER,
        p_etaj           NUMBER,
        p_nr_apartament  NUMBER,
        p_data_nastere   VARCHAR2
    );
    
    PROCEDURE insereaza_pizza_si_stoc(
        p_denumire tipuri_pizza.denumire%TYPE,
        p_gramaj tipuri_pizza.gramaj%TYPE,
        p_pret tipuri_pizza.pret%TYPE,
        p_cantitate stocuri_pizza.cantitate%TYPE
    );
    
    FUNCTION adauga_comanda(
        p_telefon_client IN clienti.telefon%TYPE
    ) RETURN NUMBER;
    
    PROCEDURE adauga_produs_comanda(
        p_telefon_client IN clienti.telefon%TYPE,
        p_id_comanda IN comenzi.id_comanda%TYPE,
        p_denumire_pizza IN tipuri_pizza.denumire%TYPE,
        p_cantitate produse_comanda.cantitate%TYPE
    );
    
    -- TODO: procedura de a insera cate un produs in comanda
END inserare_informatii;
/

CREATE OR REPLACE PACKAGE BODY inserare_informatii AS
    PROCEDURE insereaza_client_si_card(
        p_nume           VARCHAR2,
        p_prenume        VARCHAR2,
        p_telefon        VARCHAR2,
        p_email          VARCHAR2,
        p_cartier        VARCHAR2,
        p_numar_cartier  NUMBER,
        p_nr_bloc        NUMBER,
        p_etaj           NUMBER,
        p_nr_apartament  NUMBER,
        p_data_nastere   VARCHAR2
    )
    IS
        v_id_client NUMBER;
    BEGIN
        -- Inserarea în tabela "clienti"
        INSERT INTO clienti (nume, prenume, telefon, email, cartier, numar_cartier, nr_bloc, etaj, nr_apartament)
        VALUES (p_nume, p_prenume, p_telefon, p_email, p_cartier, p_numar_cartier, p_nr_bloc, p_etaj, p_nr_apartament);
        
        v_id_client := vizualizare_informatii.extrage_id_client(p_telefon);
        
        IF v_id_client != -1 THEN
            -- Inserarea în tabela "carduri_fidelitate"
            INSERT INTO carduri_fidelitate (id_client, data_nastere_client)
            VALUES (v_id_client, TO_DATE(p_data_nastere, 'dd-mon-yyyy'));
            
            COMMIT;
            DBMS_OUTPUT.PUT_LINE('S-a inserat clientul ' || p_nume || ' ' || p_prenume);
        ELSE
            DBMS_OUTPUT.PUT_LINE('Nu exista un client cu acest numar de telefon.');
            ROLLBACK;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
--            RAISE;
            DBMS_OUTPUT.PUT_LINE('Tranzactia nu s-a efectuat!!! Eroare: ' || SQLERRM);   
    END insereaza_client_si_card;
    
    PROCEDURE insereaza_pizza_si_stoc(
        p_denumire IN tipuri_pizza.denumire%TYPE,
        p_gramaj IN tipuri_pizza.gramaj%TYPE,
        p_pret IN tipuri_pizza.pret%TYPE,
        p_cantitate IN stocuri_pizza.cantitate%TYPE
    )
    IS
        v_id_pizza tipuri_pizza.id_pizza%TYPE;
    BEGIN
        -- Inserare în tabela tipuri_pizza
        INSERT INTO tipuri_pizza (denumire, gramaj, pret)
        VALUES (p_denumire, p_gramaj, p_pret)
        RETURNING id_pizza INTO v_id_pizza;

        -- Inserare în tabela stocuri_pizza
        INSERT INTO stocuri_pizza (cantitate, id_pizza)
        VALUES (p_cantitate, v_id_pizza);

        -- Commit tranzac?ie
        COMMIT;
        
        DBMS_OUTPUT.PUT_LINE('S-a inserat pizza ' || p_denumire);
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
--            RAISE;
            DBMS_OUTPUT.PUT_LINE('Tranzactia nu s-a efectuat!!! Eroare: ' || SQLERRM);  
    END;
    
    FUNCTION adauga_comanda(
        p_telefon_client IN clienti.telefon%TYPE
    ) RETURN NUMBER
    IS
        v_id_client clienti.id_client%TYPE;
        v_id_comanda comenzi.id_comanda%TYPE;
    BEGIN
        -- Extrage id-ul de client
        v_id_client := vizualizare_informatii.extrage_id_client(p_telefon_client);
        
        IF v_id_client != -1 THEN
            -- Inserare în tabela comenzi
            INSERT INTO comenzi (data_comanda, id_client, total_plata, finalizata)
            VALUES (SYSDATE, v_id_client, 0, 0)
            RETURNING id_comanda INTO v_id_comanda;
            
            COMMIT;
            DBMS_OUTPUT.PUT_LINE('Comanda cu id-ul '|| v_id_comanda || ' pentru clientul cu telefonul ' || p_telefon_client || ' a fost adaugata cu succes.');
            
            RETURN v_id_comanda;
        ELSE
            DBMS_OUTPUT.PUT_LINE('Tranzactia nu s-a efectuat!!! Eroare: Nu exista un client cu acest numar de telefon.');
            ROLLBACK;
            RETURN -1;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('Tranzactia nu s-a efectuat!!! Eroare: ' || SQLERRM);
            ROLLBACK;
    END;
    
    PROCEDURE adauga_produs_comanda(
        p_telefon_client IN clienti.telefon%TYPE,
        p_id_comanda IN comenzi.id_comanda%TYPE,
        p_denumire_pizza IN tipuri_pizza.denumire%TYPE,
        p_cantitate produse_comanda.cantitate%TYPE
    )
    IS
        v_id_client NUMBER;
        v_id_pizza tipuri_pizza.id_pizza%TYPE;
    BEGIN
        v_id_client := vizualizare_informatii.extrage_id_client(p_telefon_client);
        v_id_pizza  := vizualizare_informatii.extrage_id_pizza(p_denumire_pizza);
        
        IF v_id_client != -1 THEN
            IF v_id_pizza != -1 THEN
                INSERT INTO produse_comanda (id_comanda, id_pizza, cantitate)
                VALUES (p_id_comanda, v_id_pizza, p_cantitate);
                COMMIT;
                DBMS_OUTPUT.PUT_LINE('S-a inserat cu succes produsul ' || p_denumire_pizza || ' la comanda cu id-ul ' || p_id_comanda);
            ELSE
                DBMS_OUTPUT.PUT_LINE('Tranzatia nu s-a efectuat!!! Eroare: Nu exista tipul de pizza solicitat.');
                ROLLBACK;
            END IF;
        ELSE
            DBMS_OUTPUT.PUT_LINE('Tranzactia nu s-a efectuat!!! Eroare: Nu exista un client cu acest numar de telefon.');
            ROLLBACK;
        END IF;
        
    EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.put_line('Tranzactia de inserare a produsului nu s-a efectuat!!!');
                ROLLBACK; 
    END adauga_produs_comanda;
END inserare_informatii;
/

ALTER TABLE carduri_fidelitate
    ADD CONSTRAINT client_card_fidelitate FOREIGN KEY ( id_client )
        REFERENCES clienti ( id_client )
    NOT DEFERRABLE;

ALTER TABLE comenzi
    ADD CONSTRAINT client_comanda_fk FOREIGN KEY ( id_client )
        REFERENCES clienti ( id_client )
    NOT DEFERRABLE;

ALTER TABLE produse_comanda
    ADD CONSTRAINT prod_com_comenzi_fk FOREIGN KEY ( id_comanda )
        REFERENCES comenzi ( id_comanda )
    NOT DEFERRABLE;

ALTER TABLE produse_comanda
    ADD CONSTRAINT prod_com_tip_pizza_fk FOREIGN KEY ( id_pizza )
        REFERENCES tipuri_pizza ( id_pizza )
    NOT DEFERRABLE;

ALTER TABLE facturi
    ADD CONSTRAINT relation_14 FOREIGN KEY ( id_comanda )
        REFERENCES comenzi ( id_comanda )
    NOT DEFERRABLE;

ALTER TABLE stocuri_pizza
    ADD CONSTRAINT relation_15 FOREIGN KEY ( id_pizza )
        REFERENCES tipuri_pizza ( id_pizza )
    NOT DEFERRABLE;

CREATE OR REPLACE TRIGGER actualizare_stoc 
    AFTER UPDATE OF FINALIZATA ON Comenzi 
    FOR EACH ROW 
DECLARE
BEGIN
    IF :old.finalizata = 1 or (:old.finalizata = 0 and :new.finalizata = 0) THEN
        RAISE_APPLICATION_ERROR(-20201, 'Stocul nu poate fi actualizat!');
    ELSE
        actualizare_stoc.actualizare_stoc_la_plasarea_comenzii(:old.id_comanda);
    END IF;
END; 
/

CREATE OR REPLACE TRIGGER actualizare_total_plata_comanda 
    BEFORE UPDATE OF FINALIZATA ON Comenzi 
    FOR EACH ROW 
BEGIN
    IF :old.finalizata = 0 THEN
        SELECT SUM(pc.cantitate * tp.pret) INTO :new.total_plata from produse_comanda pc, tipuri_pizza tp WHERE :old.id_comanda = pc.id_comanda AND tp.id_pizza = pc.id_pizza; 
    END IF;
END; 
/

CREATE OR REPLACE TRIGGER actualizare_total_puncte_card_fidelitate 
    AFTER UPDATE OF FINALIZATA ON Comenzi 
    FOR EACH ROW 
DECLARE
    v_total_plata comenzi.total_plata%type;
    v_id_client clienti.id_client%type;
    v_total_puncte_anterior carduri_fidelitate.puncte_acumulate%type;
    v_total_puncte carduri_fidelitate.puncte_acumulate%type;
BEGIN
    IF :new.finalizata = 1 AND :old.finalizata = 0 THEN
        v_total_plata := :new.total_plata;
        v_id_client := :old.id_client;
--        actualizare_informatii.actualizare_puncte_card(v_total_plata, v_id_client);
        
        SELECT puncte_acumulate INTO v_total_puncte_anterior FROM carduri_fidelitate WHERE id_client = v_id_client;
	    v_total_puncte := v_total_puncte_anterior + 0.1 * v_total_plata;      
        UPDATE carduri_fidelitate SET puncte_acumulate = v_total_puncte WHERE id_client = v_id_client;
	-- TODO: exceptie pe caz contrar
    END IF;
END; 
/

CREATE OR REPLACE TRIGGER creare_factura 
    AFTER UPDATE OF FINALIZATA ON Comenzi 
    FOR EACH ROW 
BEGIN
    IF :old.finalizata = 1 or (:old.finalizata = 0 and :new.finalizata = 0) THEN
        RAISE_APPLICATION_ERROR(-20201, 'Factura nu poate fi generata de doua ori pentru aceeasi comanda!');
    ELSE
        factura_package.inserare_serie_factura(:old.id_comanda);
        factura_package.actualizare_serie_factura;
    END IF;
END; 
/

CREATE OR REPLACE TRIGGER verificare_data_comanda 
    AFTER INSERT OR UPDATE ON Comenzi 
    FOR EACH ROW 
DECLARE
    v_current_date DATE := SYSDATE;
BEGIN
    IF :NEW.data_comanda > v_current_date THEN
        RAISE_APPLICATION_ERROR(-20001, 'Data comenzii nu poate fi din viitor.');
    ELSIF :NEW.data_comanda < TRUNC(v_current_date) THEN
        RAISE_APPLICATION_ERROR(-20001, 'Data comenzii nu poate fi din trecut.');
    END IF;
END; 
/

CREATE OR REPLACE TRIGGER verificare_data_nasterii 
    AFTER INSERT OR UPDATE ON Carduri_fidelitate 
    FOR EACH ROW 
DECLARE
    current_date DATE := SYSDATE;
BEGIN
    IF (:NEW.data_nastere_client + INTERVAL '14' YEAR) > current_date THEN
        RAISE_APPLICATION_ERROR(-20001, 'Clientul trebuie sa aiba macar 14 ani impliniti.');
    END IF;
END; 
/

CREATE SEQUENCE carduri_fidelitate_id_client START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER carduri_fidelitate_id_client BEFORE
    INSERT ON carduri_fidelitate
    FOR EACH ROW
    WHEN ( new.id_client IS NULL )
BEGIN
    :new.id_client := carduri_fidelitate_id_client.nextval;
END;
/

CREATE SEQUENCE carduri_fidelitate_id_card_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER carduri_fidelitate_id_card_trg BEFORE
    INSERT ON carduri_fidelitate
    FOR EACH ROW
    WHEN ( new.id_card IS NULL )
BEGIN
    :new.id_card := carduri_fidelitate_id_card_seq.nextval;
END;
/

CREATE SEQUENCE clienti_id_client_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER clienti_id_client_trg BEFORE
    INSERT ON clienti
    FOR EACH ROW
    WHEN ( new.id_client IS NULL )
BEGIN
    :new.id_client := clienti_id_client_seq.nextval;
END;
/

CREATE SEQUENCE comenzi_id_comanda_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER comenzi_id_comanda_trg BEFORE
    INSERT ON comenzi
    FOR EACH ROW
    WHEN ( new.id_comanda IS NULL )
BEGIN
    :new.id_comanda := comenzi_id_comanda_seq.nextval;
END;
/

CREATE SEQUENCE facturi_id_factura_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER facturi_id_factura_trg BEFORE
    INSERT ON facturi
    FOR EACH ROW
    WHEN ( new.id_factura IS NULL )
BEGIN
    :new.id_factura := facturi_id_factura_seq.nextval;
END;
/

CREATE SEQUENCE facturi_numar_seq START WITH 100 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER facturi_numar_trg BEFORE
    INSERT ON facturi
    FOR EACH ROW
    WHEN ( new.numar IS NULL )
BEGIN
    :new.numar := facturi_numar_seq.nextval;
END;
/

CREATE SEQUENCE stocuri_pizza_id_intrare_stoc START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER stocuri_pizza_id_intrare_stoc BEFORE
    INSERT ON stocuri_pizza
    FOR EACH ROW
    WHEN ( new.id_intrare_stoc IS NULL )
BEGIN
    :new.id_intrare_stoc := stocuri_pizza_id_intrare_stoc.nextval;
END;
/

CREATE SEQUENCE tipuri_pizza_id_pizza_seq START WITH 1 NOCACHE ORDER;

CREATE OR REPLACE TRIGGER tipuri_pizza_id_pizza_trg BEFORE
    INSERT ON tipuri_pizza
    FOR EACH ROW
    WHEN ( new.id_pizza IS NULL )
BEGIN
    :new.id_pizza := tipuri_pizza_id_pizza_seq.nextval;
END;
/



-- Oracle SQL Developer Data Modeler Summary Report: 
-- 
-- CREATE TABLE                             7
-- CREATE INDEX                             2
-- ALTER TABLE                             34
-- CREATE VIEW                              0
-- ALTER VIEW                               0
-- CREATE PACKAGE                           6
-- CREATE PACKAGE BODY                      0
-- CREATE PROCEDURE                         0
-- CREATE FUNCTION                          0
-- CREATE TRIGGER                          14
-- ALTER TRIGGER                            0
-- CREATE COLLECTION TYPE                   0
-- CREATE STRUCTURED TYPE                   0
-- CREATE STRUCTURED TYPE BODY              0
-- CREATE CLUSTER                           0
-- CREATE CONTEXT                           0
-- CREATE DATABASE                          0
-- CREATE DIMENSION                         0
-- CREATE DIRECTORY                         0
-- CREATE DISK GROUP                        0
-- CREATE ROLE                              0
-- CREATE ROLLBACK SEGMENT                  0
-- CREATE SEQUENCE                          8
-- CREATE MATERIALIZED VIEW                 0
-- CREATE MATERIALIZED VIEW LOG             0
-- CREATE SYNONYM                           0
-- CREATE TABLESPACE                        0
-- CREATE USER                              0
-- 
-- DROP TABLESPACE                          0
-- DROP DATABASE                            0
-- 
-- REDACTION POLICY                         0
-- 
-- ORDS DROP SCHEMA                         0
-- ORDS ENABLE SCHEMA                       0
-- ORDS ENABLE OBJECT                       0
-- 
-- ERRORS                                   0
-- WARNINGS                                 0
